#应用名称，也是服务注册的名称
spring.application.name= coach-user-server
spring.zipkin.base-url= http://192.168.0.30:9411/

server.port= 8081
eureka.client.service-url.defaultZone= http://admin:admin@192.168.0.9:8761/eureka/
eureka.client.enabled= true
eureka.client.register-with-eureka= true
eureka.client.fetch-registry= true

mybatis.type-aliases-package=com.evol.mapper
mybatis.mapper-locations=classpath:*/mapper/*/*.xml


#spring.datasource.driver-class-name= com.mysql.jdbc.Driver
#spring.datasource.url= jdbc:mysql://localhost:3306/coach_order?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&useSSL=false
#spring.datasource.username= root
#spring.datasource.password= 123456

spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

# 连接池配置
# business 数据库配置
# 只有下面三个是必填项（使用内嵌数据库的话这三个也可以不用填，会使用默认配置），其他配置不是必须的
spring.datasource.name= business
spring.datasource.url= jdbc:mysql://localhost:3306/coach_business?useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&autoReconnect=true&failOverReadOnly=false&useSSL=false
spring.datasource.username= root
spring.datasource.password= 123456
spring.datasource.driver-class-name= com.mysql.jdbc.Driver
# 配置获取连接等待超时的时间
spring.datasource.druid.max-wait= 60000

#用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。
# 如果validationQuery为null,testOnBorrow,testOnBorrow,testOnReturn,testWhileIdle都不会起作用。这个可以不配置
spring.datasource.druid.validation-query= SELECT 'x'
spring.datasource.druid.test-on-borrow= false
spring.datasource.druid.test-on-return= false
spring.datasource.druid.test-while-idle= true
#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
spring.datasource.druid.time-between-eviction-runs-millis= 60000
#配置一个连接在池中最小生存的时间，单位是毫秒
spring.datasource.druid.min-evictable-idle-time-millis= 300000
spring.datasource.druid.filters= stat,wall



logging.level.com.evol.mapper=debug

#rabbitmq消息队列采集信息
spring.rabbitmq.host=127.0.0.1
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
#队列超时重试时间
spring.rabbitmq.connection-timeout=2s
##重试机制
#开启消费者(程序出现异常的情况下会,捕获异常重试将不生效)进行重试
spring.rabbitmq.listener.simple.retry.enabled=true
#最大重试次数
spring.rabbitmq.listener.simple.retry.max-attempts=5
#最大间隔时间
spring.rabbitmq.listener.simple.retry.max-interval=20000ms
#重试间隔时间 3秒
spring.rabbitmq.listener.simple.retry.initial-interval=3000ms
#乘子  重试间隔*乘子得出下次重试间隔  3s  6s  12s  24s  此处24s>20s  走20s
spring.rabbitmq.listener.simple.retry.multiplier=2
#重试次数超过上面的设置之后是否丢弃（false不丢弃时需要写相应代码将该消息加入死信队列）
spring.rabbitmq.listener.simple.default-requeue-rejected=false





